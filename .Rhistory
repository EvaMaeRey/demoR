code_string
str_extract_all(code_string, "\\{\\}")
str_extract_all(code_string, "\{\}")
str_extract_all(code_string, "\\{*\\}")
str_extract_all(code_string, "\\{.*\\}")
str_extract_all(code_string, "\\{^\\}*\\}")
str_extract_all(code_string, "\\{[^\\}]*\\}")
bob
bob = list(a = "a", "b")
bob
is.null(names(bob))
?sapply
bridge( code_string = "My dataset is {dataset}, {bob}",
user_inputs = list(dataset = "mtcars", bob = "hi")
)
bridge( code_string = "{dataset}+{bob}",
user_inputs = list(dataset = "mtcars", bob = "hi")
)
bridge( code_string = "{dataset}+{bob}",
user_inputs = list(dataset = "mtcars", "hi")
)
list(dataset = "mtcars", "hi")
bridge <- function(code_string, user_inputs = list()){
# Check that user inputs is long enough.
placeholders <- unlist(str_extract_all(code_string, "\\{[^\\}]*\\}"))
n_ph <- length(placeholders)
n_ui <- length(user_inputs)
if (n_ph > n_ui){
} else if (n_ph < n_ui) {
warn(paste0("Number of user inputs (", n_ui, ") is greater than number of placeholders (", n_ph, "). Extras will be ignored."))
user_inputs <- user_inputs[1:n_ph]
} else if (n_ph > n_ui) {
stop("Number of user inputs must match number of placeholders.")
}
# For unnamed items in list, give names from unmatched placeholders, in order of appearance.
unnamed <- map(names(user_inputs), is.null)
if (sum(unnamed) > 0){
names(user_inputs)[unnamed] <- placeholders[!(placeholders %in% names(user_inputs))]
}
# Make list of html-wrapped user inputs
col_inputs <- txt_color(user_inputs, "red")
names(col_inputs) <- names(user_inputs)
# Create string with html wrappers
my_string <- glue_data(as.list(col_inputs), code_string) %>% txt_tocode()
# Make a list of !!sym wrapped user inputs
sym_inputs <- sub_syms(names(user_inputs))
names(sym_inputs) <- names(user_inputs)
# Create expression
code_string <- glue_data(sym_inputs, code_string)
my_expr <- eval(parse(text = paste0("rlang::expr(",code_string,")")))
return(list(expr = my_expr, string = my_string))
}
sub_syms <- function(my_list){
paste0("(!!sym(user_inputs[['", x, "']]))")
}
sub_print <- function(my_list, ...){
lapply(my_list, function(x) txt_style(x, ...))
}
bridge( code_string = "{dataset}+{bob}",
user_inputs = list(dataset = "mtcars", "hi")
)
code_string = "{dataset}+{bob}",
code_string = "{dataset}+{bob}"
user_inputs = list(dataset = "mtcars", "hi")
placeholders <- unlist(str_extract_all(code_string, "\\{[^\\}]*\\}"))
n_ph <- length(placeholders)
n_ui <- length(user_inputs)
placeholders
n_ph
code_string %>%
str_extract_all("\\{[^\\}]*\\}") %>%
unlist() %>%
str_replace_all("\\}|\\{", '')
n_ui
unnamed <- map(names(user_inputs), is.null)
unnamed
names(user_inputs)
# For unnamed items in list, give names from unmatched placeholders, in order of appearance.
unnamed <- map(names(user_inputs), ~.x == "")
unnamed
sum(unnamed)
?map
# For unnamed items in list, give names from unmatched placeholders, in order of appearance.
unnamed <- map_lgl(names(user_inputs), ~.x == "")
unnamed
placeholders[!(placeholders %in% names(user_inputs))]
placeholders
placeholders <- code_string %>%
str_extract_all("\\{[^\\}]*\\}") %>%
unlist() %>%
str_replace_all("\\}|\\{", '')
placeholders[!(placeholders %in% names(user_inputs))]
bridge <- function(code_string, user_inputs = list()){
# Check that user inputs is correct length
placeholders <- code_string %>%
str_extract_all("\\{[^\\}]*\\}") %>%
unlist() %>%
str_replace_all("\\}|\\{", '')
n_ph <- length(placeholders)
n_ui <- length(user_inputs)
if (n_ph > n_ui){
stop("Number of user inputs must match number of placeholders.",
.call = FALSE)
} else if (n_ph < n_ui) {
warn(paste0("Number of user inputs (", n_ui, ") is greater than number of placeholders (", n_ph, "). Extras will be ignored."))
user_inputs <- user_inputs[1:n_ph]
}
# For unnamed items in list, give names from unmatched placeholders, in order of appearance.
unnamed <- map_lgl(names(user_inputs), ~.x == "")
if (sum(unnamed) > 0){
names(user_inputs)[unnamed] <- placeholders[!(placeholders %in% names(user_inputs))]
}
# Make list of html-wrapped user inputs
col_inputs <- txt_color(user_inputs, "red")
names(col_inputs) <- names(user_inputs)
# Create string with html wrappers
my_string <- glue_data(as.list(col_inputs), code_string) %>% txt_tocode()
# Make a list of !!sym wrapped user inputs
sym_inputs <- sub_syms(names(user_inputs))
names(sym_inputs) <- names(user_inputs)
# Create expression
code_string <- glue_data(sym_inputs, code_string)
my_expr <- eval(parse(text = paste0("rlang::expr(",code_string,")")))
return(list(expr = my_expr, string = my_string))
}
sub_syms <- function(my_list){
paste0("(!!sym(user_inputs[['", x, "']]))")
}
sub_print <- function(my_list, ...){
lapply(my_list, function(x) txt_style(x, ...))
}
bridge( code_string = "{dataset}+{bob}",
user_inputs = list(dataset = "mtcars", "hi")
)
unnamed <- map_lgl(names(user_inputs), ~.x == "")
if (sum(unnamed) > 0){
names(user_inputs)[unnamed] <- placeholders[!(placeholders %in% names(user_inputs))]
}
names(user_inputs)
col_inputs <- txt_color(user_inputs, "red")
names(col_inputs) <- names(user_inputs)
col_inputs
glue_data(as.list(col_inputs), code_string) %>% txt_tocode()
sub_syms(names(user_inputs))
names(user_inputs)
x <- names(user_inputs)
paste0("(!!sym(user_inputs[['", x, "']]))")
sub_syms(names(user_inputs))
sym_inputs
names(sym_inputs) <- names(user_inputs)
sym_inputs <- sub_syms(names(user_inputs))
names(sym_inputs) <- names(user_inputs)
# Create expression
code_string <- glue_data(sym_inputs, code_string)
sym_inputs
bridge <- function(code_string, user_inputs = list()){
# Check that user inputs is correct length
placeholders <- code_string %>%
str_extract_all("\\{[^\\}]*\\}") %>%
unlist() %>%
str_replace_all("\\}|\\{", '')
n_ph <- length(placeholders)
n_ui <- length(user_inputs)
if (n_ph > n_ui){
stop("Number of user inputs must match number of placeholders.",
.call = FALSE)
} else if (n_ph < n_ui) {
warn(paste0("Number of user inputs (", n_ui, ") is greater than number of placeholders (", n_ph, "). Extras will be ignored."))
user_inputs <- user_inputs[1:n_ph]
}
# For unnamed items in list, give names from unmatched placeholders, in order of appearance.
unnamed <- map_lgl(names(user_inputs), ~.x == "")
if (sum(unnamed) > 0){
names(user_inputs)[unnamed] <- placeholders[!(placeholders %in% names(user_inputs))]
}
# Make list of html-wrapped user inputs
col_inputs <- txt_color(user_inputs, "red")
names(col_inputs) <- names(user_inputs)
# Create string with html wrappers
my_string <- glue_data(as.list(col_inputs), code_string) %>% txt_tocode()
# Make a list of !!sym wrapped user inputs
sym_inputs <- sub_syms(names(user_inputs))
names(sym_inputs) <- names(user_inputs)
# Create expression
code_string <- glue_data(as.list(sym_inputs), code_string)
my_expr <- eval(parse(text = paste0("rlang::expr(",code_string,")")))
return(list(expr = my_expr, string = my_string))
}
sub_syms <- function(my_list){
paste0("(!!sym(user_inputs[['", x, "']]))")
}
sub_print <- function(my_list, ...){
lapply(my_list, function(x) txt_style(x, ...))
}
bridge( code_string = "{dataset}+{bob}",
user_inputs = list(dataset = "mtcars", "hi")
)
bridge( code_string = "{dataset}+{bob}",
user_inputs = list(dataset = "mtcars")
)
bridge <- function(code_string, user_inputs = list()){
# Check that user inputs is correct length
placeholders <- code_string %>%
str_extract_all("\\{[^\\}]*\\}") %>%
unlist() %>%
str_replace_all("\\}|\\{", '')
n_ph <- length(placeholders)
n_ui <- length(user_inputs)
if (n_ph > n_ui){
stop("Number of user inputs must match number of placeholders.")
} else if (n_ph < n_ui) {
warn(paste0("Number of user inputs (", n_ui, ") is greater than number of placeholders (", n_ph, "). Extras will be ignored."))
user_inputs <- user_inputs[1:n_ph]
}
# For unnamed items in list, give names from unmatched placeholders, in order of appearance.
unnamed <- map_lgl(names(user_inputs), ~.x == "")
if (sum(unnamed) > 0){
names(user_inputs)[unnamed] <- placeholders[!(placeholders %in% names(user_inputs))]
}
# Make list of html-wrapped user inputs
col_inputs <- txt_color(user_inputs, "red")
names(col_inputs) <- names(user_inputs)
# Create string with html wrappers
my_string <- glue_data(as.list(col_inputs), code_string) %>% txt_tocode()
# Make a list of !!sym wrapped user inputs
sym_inputs <- sub_syms(names(user_inputs))
names(sym_inputs) <- names(user_inputs)
# Create expression
code_string <- glue_data(as.list(sym_inputs), code_string)
my_expr <- eval(parse(text = paste0("rlang::expr(",code_string,")")))
return(list(expr = my_expr, string = my_string))
}
sub_syms <- function(my_list){
paste0("(!!sym(user_inputs[['", x, "']]))")
}
sub_print <- function(my_list, ...){
lapply(my_list, function(x) txt_style(x, ...))
}
bridge( code_string = "{dataset}",
user_inputs = list(dataset = "mtcars", "hi")
)
library(usethis)
usethis::use_vignette()
?use_vignette
usethis::use_vignette("using-demoR")
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
data(iris)
codestring <- "mean(iris$Sepal.Length)"
hlt_vars(codestring)
devtools::load_all(".")
data(iris)
codestring <- "mean(iris$Sepal.Length)"
hlt_vars(codestring)
data(iris)
codestring <- "mean(iris$Sepal.Length)"
hlt_funs(codestring)
data(iris)
codestring <- "mean(iris$Sepal.Length)"
hlt_funs(codestring)
hlt_specific(codestring, "iris", color = "blue")
code_string <- "ggplot(data = mtcars, aes(x = mpg, y = disp)) + geom_point()"
aes_option <- "color = cyl"
ggcompare(code_string, aes_option)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
eval = FALSE
)
codestring <- "mean(iris$Sepal.Length)"
parse(codestring)
parse(text = codestring)
?parse
bob <- parse(text = codestring)
ast(bob
)
install.packages("codetools")
ast(bob
)
library(codetools)
ast(bob)
findGlobals(bob)
bob
??ast
install.packages("pryr")
library(pryr)
ast(bob)
bob
bob <- quote(codestring)
ast(bob)
ast(mean(iris$Sepal.Length))
ast(mean(iris$Sepal.Length))[1]
ast(mean(iris$Sepal.Length))[[1]]
ast(!!bob)
!!bob
eval(bob)
bob
bob <- parse(text = codestring)
bob
eval(bob)
!!bob
ast(eval(bob))
typeof(bob)
typeof(bob)[1]
typeof(bob)[[1]]
bob[[1]]
bob[[2]]
bob <- quote(mean(iris$Sepal.Length))
bob
bob[1]
bob[[1]]
bob[[2]]
bob <- quote(x <-  mean(iris$Sepal.Length))
bob <- quote(x <-  mean(iris$Sepal.Length))
bob
bob[1]
bob[2]
bob[3]
bob[[1]]
bob[[2]]
bob[[3]]
bob[[4]]
bob[[3]][1]
bob[[3]][2]
bob[[3]][2][1]
bob[[3]][[1]]
bob[[3]][[2]]
str(bob[[3]][[2]])
is.atomic(bob[[1]])
is.call(bob[[1]])
is.name(bob[[1]])
is.pairlist(bob[[1]])
is.pairlist(bob[[2]])
is.atomic(bob[[2]])
is.call(bob[[2]])
is.name(bob[[2]])
is.pairlist(bob[[2]])
bob[[2]]
bob[[1]]
is.call(bob[[1]])
is.call(bob[1])
bob[1]
bob[2]
bob[3]
unlist(bob)
bob
is.atomic(bob[[3]])
is.call(bob[[3]])
is.name(bob[[3]])
is.pairlist(bob[[3]])
bob[[3]]
is.atomic(bob[[3]][1])
is.call(bob[[3]][1])
is.call(bob[[3]][[1]])
is.name(bob[[3]][[1]])
is.name(bob[[3]][[2]])
length(bob)
bob <- quote(x <-  mean(sqrt(iris$Sepal.Length)))
length(bob)
bob[3]
bob[2]
bob[2][[1]]
bob[2][1]
get_function_names <- function(quote){
fns <- NULL
for(i in 1:length(quote)){
if(is.call(quote[i])){
funs <- c(funs, quote[[i]])
}else if(is.pairlist(quote[i])){
funs <- c(funs, get_function_names(quote[i]))
}
}
return(fns)
}
get_function_names(bob)
quote = bob
length(quote)
is.call(quote[i]
)
is.call(bob[1])
bob[1]
bob[[1]]
is.pairlist(bob[1])
is.pairlist(bob[2])
bob[2]
bob
is.pairlist(bob[3])
get_function_names <- function(quote){
fns <- NULL
for(i in 1:length(quote)){
if(is.call(quote[i])){
fns <- c(fns, quote[[i]])
}else if(is.pairlist(quote[i])){
fns <- c(fns, get_function_names(quote[i]))
}
}
return(fns)
}
get_function_names(bob)
is.call(bob[2])
bob[2]
is.atomic(bob)
seq_along(bob)
browseVignettes(package = "highr")
bob <- quote(x <-  mean(iris$Sepal.Length))
bob
bob[1]
bob[2]
bob[[1]]
bob[[2]]
bob[[3]]
bob[[3]][1]
bob[[3]][2]
bob[[3]][[1]]
bob[[3]][[2]]
#Figuring out types:
is.atomic(bob[[1]])
is.call(bob[[1]])
is.name(bob[[1]])
is.pairlist(bob[[1]])
is.atomic(bob[1])
is.call(bob[1])
is.name(bob[1])
is.atomic(bob[[2]])
is.call(bob[[2]])
is.name(bob[[2]])
is.pairlist(bob[[2]])
is.atomic(bob[[3]])
is.call(bob[[3]])
is.name(bob[[3]])
is.pairlist(bob[[3]])
### Try to find all function names....?
bob <- quote(x <-  mean(sqrt(iris$Sepal.Length)))
get_function_names <- function(quote){
fns <- NULL
for(i in 1:length(quote)){
if(is.call(quote[i])){
fns <- c(fns, quote[[i]])
}else if(is.pairlist(quote[i])){
fns <- c(fns, get_function_names(quote[i]))
}
}
return(fns)
}
get_function_names(bob)
iris %>%
group_by({Species}) %>%  # hlt
summarize(mean = Sepal.Length)
library(tidyverse)
#### Design.... ####
# Using comments is nice because the code runs
iris %>%
group_by(Species) %>%  # hlt
summarize(mean = Sepal.Length)
# Same with curlies?
iris %>%
group_by({Species}) %>%  # hlt
summarize(mean = Sepal.Length)
library(tidyverse)
#### Design.... ####
# Using comments is nice because the code runs
iris %>%
group_by(Species) %>%  # hlt
summarize(mean = mean(Sepal.Length) )
# Same with curlies?
iris %>%
group_by({Species}) %>%  # hlt
summarize(mean = mean(Sepal.Length) )
library(tidyverse)
#### Design.... ####
# Using comments is nice because the code runs
iris %>%
group_by(Species) %>%  # hlt
summarize(mean = mean(Sepal.Length) )
# Same with curlies?
iris %>%
group_by({{Species}}) %>%  # hlt
summarize(mean = mean(Sepal.Length) )
library(tidyverse)
#### Design.... ####
# Using comments is nice because the code runs
iris %>%
group_by(Species) %>%  # hlt
summarize(mean = mean(Sepal.Length) )
# Same with curlies?
iris %>%
group_by(``Species``) %>%  # hlt
summarize(mean = mean(Sepal.Length) )
library(tidyverse)
#### Design.... ####
# Using comments is nice because the code runs
iris %>%
group_by(Species) %>%  # hlt
summarize(mean = mean(Sepal.Length) )
# Same with curlies?
iris %>%
{ group_by(Species) %>% } # hlt
summarize(mean = mean(Sepal.Length) )
iris %>%
{{ group_by(Species) %>% }} # hlt
?`>>`
iris %>%
group_by(*Species) %>%  # hlt
summarize(mean = Sepal.Length)
iris %>%
group_by(Species*) %>%  # hlt
summarize(mean = Sepal.Length)
iris %>%
*  group_by(Species) %>%  # hlt
summarize(mean = Sepal.Length)
